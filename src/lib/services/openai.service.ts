import type {
  OpenAIRecommendationParams,
  OpenAIRecommendationResponse,
  OpenAIArtistBioParams,
  OpenAIArtistBioResponse,
} from "../../types";
import { logError, OpenAIAPIError, AIGenerationError } from "../utils/errors";

/**
 * Service class for OpenAI API integration
 * Handles AI-powered track recommendations and artist biography generation
 */
export class OpenAIService {
  private readonly apiKey: string;
  private readonly baseURL = "https://api.openai.com/v1";
  private readonly model = "gpt-4o-mini";

  constructor() {
    this.apiKey = import.meta.env.OPENAI_API_KEY;

    if (!this.apiKey) {
      throw new Error("OpenAI API key must be provided in environment variables");
    }
  }

  /**
   * Generates AI-powered track recommendations based on a base track and user description
   * @param params Parameters for recommendation generation
   * @returns Recommended track IDs with reasoning and confidence scores
   * @throws OpenAIAPIError for API failures
   * @throws AIGenerationError for generation failures
   */
  async generateRecommendations(params: OpenAIRecommendationParams): Promise<OpenAIRecommendationResponse> {
    const startTime = Date.now();

    try {
      const prompt = this.buildRecommendationPrompt(params);

      const response = await fetch(`${this.baseURL}/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: "system",
              content: `You are an expert music curator specializing in metal music. Your task is to recommend tracks similar to the provided base track based on user preferences. Always return valid JSON responses.`,
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          // NOTE: We use a fixed low OpenAI temperature (0.3) for consistent, structured responses
          // The musical "temperature" (popular vs niche) is handled in the prompt text, not here
          // OpenAI temperature controls randomness of token generation, not music style preference
          temperature: 0.3, // Fixed low temperature for consistent, structured responses
          max_tokens: 2000,
          response_format: { type: "json_object" },
        }),
      });

      if (!response.ok) {
        if (response.status === 429) {
          throw new OpenAIAPIError("OpenAI rate limit exceeded", 429);
        }

        if (response.status >= 500) {
          throw new OpenAIAPIError("OpenAI service temporarily unavailable", 503);
        }

        throw new OpenAIAPIError(`OpenAI API error: ${response.status} ${response.statusText}`, response.status);
      }

      const data = await response.json();

      if (!data.choices || !data.choices[0] || !data.choices[0].message) {
        throw new AIGenerationError("Invalid response format from OpenAI API");
      }

      const generatedContent = data.choices[0].message.content;
      const parsedResponse = this.parseRecommendationResponse(generatedContent);

      // Validate response structure
      if (!parsedResponse.recommendations || !Array.isArray(parsedResponse.recommendations)) {
        throw new AIGenerationError("Invalid recommendations in AI response");
      }

      if (parsedResponse.recommendations.length === 0) {
        throw new AIGenerationError("No recommendations generated by AI");
      }

      // Filter out excluded tracks (by checking if artist+song combination exists in library/blocked)
      // Note: We can't directly filter by track ID since we don't have them yet
      // This filtering will be done later in the workflow after Spotify search
      const result: OpenAIRecommendationResponse = {
        recommendations: parsedResponse.recommendations, // Return all generated recommendations
      };

      // DETAILED LOGGING: Log all AI generated recommendations before Spotify search
      console.info("DETAILED: OpenAI generated recommendations", {
        operation: "openai_generate_recommendations_detailed",
        requested_count: params.count,
        actual_generated_count: result.recommendations.length,
        temperature: params.temperature,
        base_track: {
          name: params.base_track.name,
          artists: params.base_track.artists,
        },
        user_description: params.description,
        generated_recommendations: result.recommendations.map((rec, idx) => ({
          index: idx,
          song_title: rec.song_title,
          artist_name: rec.artist_name,
          reasoning: rec.reasoning,
          confidence: rec.confidence,
        })),
        timestamp: new Date().toISOString(),
      });

      console.info("OpenAI recommendations generated successfully", {
        operation: "openai_generate_recommendations",
        generated_count: result.recommendations.length,
        generation_time_ms: Date.now() - startTime,
        temperature: params.temperature,
        timestamp: new Date().toISOString(),
      });

      return result;
    } catch (error) {
      if (error instanceof OpenAIAPIError || error instanceof AIGenerationError) {
        throw error;
      }

      const openAIError = new OpenAIAPIError(
        "Unexpected error during AI recommendation generation",
        503,
        error as Error
      );

      logError(openAIError, {
        operation: "openai_generate_recommendations",
        params: {
          base_track: params.base_track.name,
          temperature: params.temperature,
          count: params.count,
        },
        generation_time_ms: Date.now() - startTime,
      });

      throw openAIError;
    }
  }

  /**
   * Generates AI-powered artist biography focusing on metal music contribution
   * @param params Parameters for biography generation
   * @returns Generated artist biography
   * @throws OpenAIAPIError for API failures
   * @throws AIGenerationError for generation failures
   */
  async generateArtistBio(params: OpenAIArtistBioParams): Promise<OpenAIArtistBioResponse> {
    try {
      const prompt = this.buildArtistBioPrompt(params);

      const response = await fetch(`${this.baseURL}/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: "system",
              content: `You are a music historian specializing in metal music. Write concise, informative artist biographies that focus on the artist's contribution to metal music and their distinctive style.`,
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          temperature: 0.3, // Lower temperature for more factual content
          max_tokens: 300,
        }),
      });

      if (!response.ok) {
        throw new OpenAIAPIError(`OpenAI API error during biography generation: ${response.status}`, response.status);
      }

      const data = await response.json();

      if (!data.choices || !data.choices[0] || !data.choices[0].message) {
        throw new AIGenerationError("Invalid response format from OpenAI API for biography");
      }

      const biography = data.choices[0].message.content.trim();

      if (!biography || biography.length < 50) {
        throw new AIGenerationError("Generated biography is too short or empty");
      }

      return { biography };
    } catch (error) {
      if (error instanceof OpenAIAPIError || error instanceof AIGenerationError) {
        throw error;
      }

      const openAIError = new OpenAIAPIError(
        "Unexpected error during artist biography generation",
        503,
        error as Error
      );

      logError(openAIError, {
        operation: "openai_generate_artist_bio",
        artist_name: params.artist_name,
      });

      throw openAIError;
    }
  }

  /**
   * Builds the prompt for AI track recommendation generation
   * @private
   */
  private buildRecommendationPrompt(params: OpenAIRecommendationParams): string {
    const baseTrackInfo = `Base track: "${params.base_track.name}" by ${params.base_track.artists.join(", ")}`;
    const genresInfo = params.base_track.genres?.length
      ? `Genres: ${params.base_track.genres.join(", ")}`
      : "Genres: Not specified";

    // Build excluded tracks section
    const excludedTracksInfo =
      params.excluded_tracks.length > 0
        ? `
IMPORTANT - DO NOT RECOMMEND THESE TRACKS (user already has them or blocked them):
${params.excluded_tracks.map((track) => `- ${track}`).join("\n")}

Please ensure none of your recommendations match any of the tracks listed above.`
        : "";

    // Build temperature-specific instructions
    const temperatureGuidance = this.getTemperatureGuidance(params.temperature);

    return `
${baseTrackInfo}
${genresInfo}

User's preference description: "${params.description}"
${excludedTracksInfo}

Please recommend ${params.count} metal tracks similar to the base track that match the user's preferences. 

TEMPERATURE SETTING: ${params.temperature}
${temperatureGuidance}

Requirements:
1. YOU MUST provide exactly ${params.count} recommendations - never fewer, never more
2. Focus on metal subgenres and similar aggressive/atmospheric elements
3. Use exact song titles and artist names (not Spotify IDs)
4. Balance discoverability with the temperature guidance above
5. Avoid extremely obscure B-sides or demo tracks that might not be on Spotify
6. Include reasoning for each recommendation
7. Provide confidence scores (0.0-1.0)
8. If you struggle to find enough tracks matching the temperature level, use the fallback strategy above

CRITICAL: The response array MUST contain exactly ${params.count} recommendation objects.

Return a JSON object with this exact structure:
{
  "recommendations": [
    {
      "song_title": "The Trooper",
      "artist_name": "Iron Maiden",
      "reasoning": "Similar galloping rhythm and powerful vocals that match the user's preference for aggressive guitar riffs",
      "confidence": 0.92
    },
    {
      "song_title": "Breaking the Law", 
      "artist_name": "Judas Priest",
      "reasoning": "Classic heavy metal with driving guitar work and similar energy",
      "confidence": 0.87
    }
  ]
}

Ensure all song titles and artist names are accurate and the tracks are available on Spotify.
`;
  }

  /**
   * Generates temperature-specific guidance for AI recommendations
   * @private
   */
  private getTemperatureGuidance(temperature: number): string {
    if (temperature <= 0.3) {
      return `
LOW TEMPERATURE (${temperature}) - Focus on POPULAR/MAINSTREAM recommendations:
- Prioritize well-known, popular metal bands (Iron Maiden, Metallica, Black Sabbath, Judas Priest, etc.)
- Include chart-topping songs and classic metal anthems
- Focus on bands with millions of monthly listeners on Spotify
- Prefer bands that regularly headline major festivals
- These should be tracks most metal fans would recognize immediately

CRITICAL: You MUST provide exactly the requested number of recommendations. Never return fewer tracks.`;
    } else if (temperature <= 0.6) {
      return `
MEDIUM TEMPERATURE (${temperature}) - Balance POPULAR and LESSER-KNOWN recommendations:
- Mix well-known bands (60%) with moderately popular ones (40%)
- Include some deeper cuts from popular bands alongside their hits
- Consider bands with 100k-1M monthly listeners on Spotify
- Mix festival headliners with strong support acts
- Balance recognizable names with quality discoveries

CRITICAL: You MUST provide exactly the requested number of recommendations. Never return fewer tracks.`;
    } else {
      return `
HIGH TEMPERATURE (${temperature}) - Prioritize NICHE/UNDERGROUND but ensure COMPLETENESS:
- TARGET DISTRIBUTION: 70% lesser-known/underground + 30% moderately known bands if needed
- PRIMARY FOCUS: Bands with under 500k monthly listeners (cult favorites, regional scenes, hidden gems)
- SECONDARY FOCUS: If you can't find enough niche tracks, include moderately popular bands but avoid mega-mainstream ones
- ACCEPTABLE: Deeper cuts from known bands, B-sides, or lesser-known albums from popular artists
- AVOID ONLY: The most obvious mainstream hits (e.g., "Enter Sandman", "The Trooper", "Paranoid")

FALLBACK STRATEGY: If struggling to find enough underground tracks, prioritize:
1. Newer/emerging metal bands
2. Regional metal scenes (European, South American, etc.)
3. Underrated albums from moderately known bands
4. Subgenre-specific cult classics

CRITICAL: You MUST provide exactly the requested number of recommendations. Completeness is more important than perfect niche-ness.`;
    }
  }

  /**
   * Builds the prompt for AI artist biography generation
   * @private
   */
  private buildArtistBioPrompt(params: OpenAIArtistBioParams): string {
    // Safely handle undefined or empty genres array
    const genres = params.genres || [];
    const genresInfo = genres.length > 0 ? `Genres: ${genres.join(", ")}` : "";

    return `
Write a concise 5-sentence biography for the metal artist "${params.artist_name}".
${genresInfo}

Focus on:
1. Their contribution to metal music
2. Their distinctive style and musical approach
3. Key albums or career highlights
4. Their influence on the metal scene
5. What makes them unique in the metal genre

Keep it informative but concise. Do not include speculation or unverified information.
`;
  }

  /**
   * Parses the JSON response from OpenAI recommendation generation
   * @private
   */
  private parseRecommendationResponse(content: string): OpenAIRecommendationResponse {
    try {
      const parsed = JSON.parse(content);

      if (!parsed || typeof parsed !== "object") {
        throw new Error("Invalid JSON structure");
      }

      return {
        recommendations: parsed.recommendations || [],
      };
    } catch (error) {
      throw new AIGenerationError(
        `Failed to parse AI response: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
}
