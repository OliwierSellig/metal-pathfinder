# API Endpoint Implementation Plan: AI Recommendations

## 1. Przegląd punktu końcowego

Endpoint **POST /api/spotify/recommendations** służy do generowania inteligentnych rekomendacji utworów muzycznych przy użyciu analizy AI preferencji użytkownika. System łączy dane z Spotify Web API z zaawansowanymi możliwościami OpenAI API, aby dostarczyć spersonalizowane rekomendacje wraz z uzasadnieniami i biografiami wykonawców. Na tym etapie rozwoju używa mockup użytkownika (TEST_USER_ID) zamiast pełnej walidacji JWT.

## 2. Szczegóły żądania

- **Metoda HTTP:** POST
- **Struktura URL:** `/api/spotify/recommendations`
- **Parametry:**
  - **Wymagane (Request Body):**
    - `base_track_id` (string) - identyfikator utworu Spotify z biblioteki użytkownika
      - Dokładnie 22 znaki alfanumeryczne + podkreślnik/myślnik
      - Musi istnieć w bibliotece użytkownika
    - `description` (string) - opis preferencji użytkownika
      - Minimum: 30 znaków
      - Maksimum: 500 znaków
    - `temperature` (number) - poziom popularności vs. niszowość
      - Zakres: 0.0 (popularne) do 1.0 (niszowe)
      - Typ: float
  - **Opcjonalne (Request Body):**
    - `count` (integer) - liczba rekomendacji do wygenerowania
      - Domyślnie: 10
      - Zakres: 1-10
- **Headers:** Brak (na razie używamy mockup użytkownika)
- **Request Body:** JSON

```json
{
  "base_track_id": "4iV5W9uYEdYUVa79Axb7Rh",
  "description": "Szukam utworów z agresywnym graniem na perkusji i mroczną atmosferą, podobnie jak w tym utworze",
  "temperature": 0.7,
  "count": 10
}
```

## 3. Szczegóły odpowiedzi

**Struktura odpowiedzi (200 OK):**

```json
{
  "recommendations": [
    {
      "spotify_track_id": "string",
      "name": "string",
      "artists": [
        {
          "name": "string",
          "spotify_artist_id": "string"
        }
      ],
      "album": {
        "name": "string",
        "images": [
          {
            "url": "https://...",
            "height": 640,
            "width": 640
          }
        ]
      },
      "duration_ms": 240000,
      // preview_url removed - no audio functionality
      "ai_reasoning": "This track shares the aggressive drumming style and dark atmospheric elements you described in your base track.",
      "artist_bio": "Five-sentence biography of the artist generated by AI, focusing on their contribution to metal music and style.",
      "popularity_score": 45, // 0-100, influenced by temperature parameter
      "recommendation_confidence": 0.85 // AI confidence in this recommendation
    }
  ],
  "base_track": {
    "spotify_track_id": "string",
    "name": "string",
    "artists": [{ "name": "string" }]
  },
  "generation_metadata": {
    "ai_model": "gpt-4o-mini",
    "temperature_used": 0.7,
    "description_processed": "Truncated/processed version of user description",
    "excluded_tracks_count": 5, // tracks excluded due to library/blocks
    "generation_time_ms": 1250
  }
}
```

**Kody statusu:**

- `200 OK` - Rekomendacje wygenerowane pomyślnie
- `400 Bad Request` - Nieprawidłowy base_track_id, za krótki opis, lub nieprawidłowy temperature
- `404 Not Found` - Bazowy utwór nie znaleziony w bibliotece użytkownika
- `422 Unprocessable Entity` - Generowanie AI nie powiodło się lub niewystarczająca liczba utworów metalowych
- `429 Too Many Requests` - Przekroczony limit żądań
- `503 Service Unavailable` - API Spotify lub OpenAI niedostępne
- `500 Internal Server Error` - Błąd wewnętrzny serwera

## 4. Przepływ danych

1. **Mockup użytkownika:**

   - Użycie TEST_USER_ID z supabase.client.ts do symulacji użytkownika
   - Brak walidacji uwierzytelnienia na tym etapie

2. **Walidacja parametrów wejściowych:**

   - Sprawdzenie formatu base_track_id (22 znaki)
   - Walidacja długości description (30-500 znaków)
   - Walidacja temperature (0.0-1.0)
   - Walidacja count (1-10)

3. **Walidacja base_track w bibliotece:**

   - Sprawdzenie czy base_track_id istnieje w bibliotece użytkownika
   - Pobranie szczegółów bazowego utworu z Spotify

4. **Pobranie list wykluczeń:**

   - Równoległe pobranie utworów z biblioteki użytkownika
   - Pobranie aktywnych zablokowanych utworów
   - Kombinowanie obu list do wykluczenia

5. **Uwierzytelnienie zewnętrznych API:**

   - Pobranie access token Spotify z cache lub odnowienie
   - Przygotowanie API key dla OpenAI

6. **Generowanie rekomendacji AI:**

   - Budowanie zaawansowanego prompt'u opartego na base track i opisie
   - Wywołanie OpenAI API z modelem gpt-4o-mini
   - Parsowanie odpowiedzi AI (track IDs, reasoning, confidence)

7. **Wzbogacanie rekomendacji:**

   - Równoległe pobieranie szczegółów utworów ze Spotify
   - Generowanie biografii wykonawców przez AI
   - Filtrowanie według excluded tracks
   - Mapowanie na własne DTO

8. **Cache i optymalizacja:**
   - Cache podobnych zapytań (krótki TTL ze względu na personalizację)
   - Cache tokenów Spotify i szczegółów utworów

## 5. Względy bezpieczeństwa

- **Mockup użytkownika (tymczasowo):**

  - Używanie TEST_USER_ID z supabase.client.ts
  - Brak walidacji uwierzytelnienia na tym etapie rozwoju
  - Uwaga: W produkcji wymagana będzie pełna implementacja JWT

- **API Keys Security:**

  - OpenAI API key przechowywany w zmiennych środowiskowych
  - Spotify Client Credentials przechowywane bezpiecznie
  - Monitoring użycia API i kosztów

- **Walidacja danych wejściowych:**

  - Strict validation wszystkich parametrów
  - Sanityzacja opisów użytkownika przed OpenAI
  - Walidacja biblioteki użytkownika przeciwko base_track

- **Rate Limiting i koszty:**
  - Podstawowy rate limiting na poziomie aplikacji
  - Monitoring kosztów OpenAI API
  - Timeout protection dla długich operacji AI
  - Uwaga: Per-user rate limiting zostanie dodany po implementacji pełnej autentykacji

## 6. Obsługa błędów

**Walidacja parametrów (400 Bad Request):**

- Nieprawidłowy format base_track_id (nie 22 znaki)
- Opis za krótki (<30 znaków) lub za długi (>500 znaków)
- Temperature poza zakresem (nie 0.0-1.0)
- Count poza zakresem (nie 1-10)
- Malformed JSON w request body

**Zasób nie znaleziony (404 Not Found):**

- Base track nie istnieje w bibliotece użytkownika
- Base track usunięty z katalogu Spotify
- Biblioteka użytkownika pusta

**Błędy przetwarzania (422 Unprocessable Entity):**

- Generowanie AI zwróciło błąd lub puste wyniki
- Insufficient metal tracks available w katalogu
- AI nie potrafiło zinterpretować opisu użytkownika
- Wszystkie rekomendacje AI znajdują się na liście wykluczeń

**Rate Limiting (429 Too Many Requests):**

- Przekroczenie limitu aplikacji
- Przekroczenie limitu OpenAI API
- Przekroczenie limitu Spotify API
- Implementacja exponential backoff

**Zewnętrzne serwisy (503 Service Unavailable):**

- Niedostępność OpenAI API
- Niedostępność Spotify API
- Timeout przy wywołaniach zewnętrznych
- Błędy sieci i connectivity

**Błędy wewnętrzne (500 Internal Server Error):**

- Błędy transformacji danych
- Błędy parsowania odpowiedzi AI
- Nieoczekiwane wyjątki aplikacji
- Database connection errors

## 7. Rozważania dotyczące wydajności

**Strategia cache'owania:**

- Cache podobnych zapytań: krótki TTL (15 minut) ze względu na personalizację
- Cache szczegółów utworów Spotify: 24 godziny TTL
- Cache tokenów Spotify: do czasu wygaśnięcia
- Cache biografii wykonawców: 7 dni TTL

**Optymalizacja żądań:**

- Równoległe wywołania do Spotify dla multiple tracks
- Batch processing dla artist biographies
- Connection pooling dla wszystkich zewnętrznych API
- Streaming responses dla długich operacji

**Monitoring kosztów:**

- Tracking użycia OpenAI API (tokens, requests)
- Monitoring czasu odpowiedzi endpointu
- Alerting przy przekroczeniu budżetu API

**Skalowanie:**

- Horizontal scaling readiness
- Background job processing dla długich AI operations
- CDN dla statycznych assets

## 8. Etapy wdrożenia

### Krok 1: Przygotowanie struktury plików

- Utworzenie `/src/pages/api/spotify/recommendations.ts`
- Rozszerzenie typów DTO w `/src/types.ts`
- Utworzenie service w `/src/lib/services/openai.service.ts`
- Rozszerzenie `/src/lib/services/spotify.service.ts`

### Krok 2: Implementacja typów i walidacji

- Zdefiniowanie `AIRecommendationsRequest` i `AIRecommendationsResponse` DTOs
- Dodanie `AIRecommendation`, `GenerationMetadata` types
- Implementacja walidacji parametrów używając Zod
- Walidacja base_track_id, description, temperature, count

### Krok 3: Implementacja OpenAIService

- Metoda `generateRecommendations()` w openai.service.ts z modelem gpt-4o-mini
- Metoda `generateArtistBio()` w openai.service.ts z modelem gpt-4o-mini
- Advanced prompt engineering dla rekomendacji
- Error handling i retry logic dla OpenAI calls
- Cost optimization wykorzystując najnowszy najtańszy model

### Krok 4: Rozszerzenie SpotifyService

- Metoda `getTrackDetails()` już istnieje
- Metoda `validateTrackInLibrary()` w spotify.service.ts
- Batch methods dla multiple track details
- Integration z Library i BlockedTracks services

### Krok 5: Implementacja endpointu API

- Handler POST w `/src/pages/api/spotify/recommendations.ts`
- Użycie TEST_USER_ID z supabase.client.ts jako mockup użytkownika
- Orchestration wszystkich services
- Response mapping i error handling

### Krok 6: Implementacja prompt engineering

- Advanced prompt templates dla różnych temperature levels
- Dynamic prompt building based na base track metadata
- Optimization dla metal music domain
- A/B testing różnych prompt strategies

### Krok 7: Integracja z biblioteką i blokadami

- Integration z LibraryService dla exclusion list
- Integration z BlockedTracksService dla active blocks
- Validation logic dla base_track w library
- Performance optimization dla large libraries

### Krok 8: Implementacja cache'owania i optimizacji

- Multi-layer caching strategy
- Background processing dla expensive operations
- Monitoring i alerting dla API usage
- Cost optimization dla OpenAI calls

### Krok 9: Testy i walidacja

- Unit testy dla wszystkich service methods
- Integration testy dla complex AI workflow
- Testy różnych temperature levels i edge cases
- Performance testing dla large datasets

### Krok 10: Dokumentacja i monitoring

- Comprehensive API documentation
- Monitoring dashboards dla AI performance
- Cost tracking i budget alerts
- Security audit i penetration testing
