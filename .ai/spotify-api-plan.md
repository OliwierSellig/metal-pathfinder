# Spotify API Plan - MetalPathfinder

## 1. Resources

### Primary Resources

- **Track Search** - Search Spotify catalog for metal tracks during onboarding and library building
- **Track Details** - Retrieve detailed metadata for specific Spotify tracks
- **AI Recommendations** - Generate intelligent track recommendations using OpenAI + Spotify data

### Authentication Model

- **Spotify Integration**: Client Credentials Flow (application-level authentication)
- **User Authentication**: Supabase JWT (for API access control)
- **No Spotify OAuth**: Users do not authenticate with Spotify directly

## 2. Endpoints

### 2.1 Track Search

#### GET /api/spotify/search

**Description:** Search Spotify catalog for tracks, optimized for metal music discovery
**Authentication:** Required (Supabase JWT)
**Query Parameters:**

- `q` (required) - Search query string (track name, artist, album)
- `limit` (optional, default: 20, max: 50) - Number of results to return
- `offset` (optional, default: 0) - Pagination offset
- `market` (optional, default: "US") - Market for track availability

**Response:**

```json
{
  "tracks": [
    {
      "spotify_track_id": "string",
      "name": "string",
      "artists": [
        {
          "name": "string",
          "spotify_artist_id": "string"
        }
      ],
      "album": {
        "name": "string",
        "spotify_album_id": "string",
        "release_date": "2023-01-01",
        "images": [
          {
            "url": "https://...",
            "height": 640,
            "width": 640
          }
        ]
      },
      "duration_ms": 240000,
      "preview_url": "https://..." // nullable
    }
  ],
  "total": 1000,
  "limit": 20,
  "offset": 0,
  "has_more": true
}
```

**Success Codes:**

- `200 OK` - Search completed successfully

**Error Codes:**

- `400 Bad Request` - Missing or invalid query parameter
- `401 Unauthorized` - Invalid or missing Supabase JWT
- `429 Too Many Requests` - Rate limit exceeded
- `503 Service Unavailable` - Spotify API unavailable

### 2.2 Track Details

#### GET /api/spotify/track/{spotify_track_id}

**Description:** Get detailed information about a specific track
**Authentication:** Required (Supabase JWT)
**Path Parameters:**

- `spotify_track_id` - Spotify track ID (22 characters)

**Query Parameters:**

- `market` (optional, default: "US") - Market for track availability

**Response:**

```json
{
  "spotify_track_id": "string",
  "name": "string",
  "artists": [
    {
      "name": "string",
      "spotify_artist_id": "string",
      "genres": ["black metal", "death metal"]
    }
  ],
  "album": {
    "name": "string",
    "spotify_album_id": "string",
    "release_date": "2023-01-01",
    "total_tracks": 10,
    "images": [
      {
        "url": "https://...",
        "height": 640,
        "width": 640
      }
    ]
  ],
  "duration_ms": 240000,
  "preview_url": "https://...", // nullable
  "explicit": false,
  "popularity": 65
}
```

**Success Codes:**

- `200 OK` - Track details retrieved successfully

**Error Codes:**

- `400 Bad Request` - Invalid spotify_track_id format
- `401 Unauthorized` - Invalid or missing Supabase JWT
- `404 Not Found` - Track not found or not available in market
- `429 Too Many Requests` - Rate limit exceeded
- `503 Service Unavailable` - Spotify API unavailable

### 2.3 AI Recommendations

#### POST /api/spotify/recommendations

**Description:** Generate intelligent track recommendations using AI analysis of user preferences
**Authentication:** Required (Supabase JWT)
**Request Body:**

```json
{
  "base_track_id": "string", // Required, Spotify track ID from user's library
  "description": "string", // Required, min 30 chars, user's preference description
  "temperature": 0.7, // Required, 0.0 (popular) to 1.0 (niche)
  "count": 10 // Optional, default: 10, max: 10
}
```

**Response:**

```json
{
  "recommendations": [
    {
      "spotify_track_id": "string",
      "name": "string",
      "artists": [
        {
          "name": "string",
          "spotify_artist_id": "string"
        }
      ],
      "album": {
        "name": "string",
        "images": [
          {
            "url": "https://...",
            "height": 640,
            "width": 640
          }
        ]
      },
      "duration_ms": 240000,
      "preview_url": "https://...", // nullable
      "ai_reasoning": "This track shares the aggressive drumming style and dark atmospheric elements you described in your base track.",
      "artist_bio": "Five-sentence biography of the artist generated by AI, focusing on their contribution to metal music and style.",
      "popularity_score": 45, // 0-100, influenced by temperature parameter
      "recommendation_confidence": 0.85 // AI confidence in this recommendation
    }
  ],
  "base_track": {
    "spotify_track_id": "string",
    "name": "string",
    "artists": [{ "name": "string" }]
  },
  "generation_metadata": {
    "ai_model": "gpt-4o-mini",
    "temperature_used": 0.7,
    "description_processed": "Truncated/processed version of user description",
    "excluded_tracks_count": 5, // tracks excluded due to library/blocks
    "generation_time_ms": 1250
  }
}
```

**Success Codes:**

- `200 OK` - Recommendations generated successfully

**Error Codes:**

- `400 Bad Request` - Invalid base_track_id, description too short, or invalid temperature
- `401 Unauthorized` - Invalid or missing Supabase JWT
- `404 Not Found` - Base track not found in user's library
- `422 Unprocessable Entity` - AI generation failed or insufficient metal tracks available
- `429 Too Many Requests` - Rate limit exceeded
- `503 Service Unavailable` - Spotify or OpenAI API unavailable

## 3. Authentication and Authorization

### Authentication Method

- **User Authentication:** Supabase JWT tokens in Authorization header
- **Spotify Authentication:** Server-side Client Credentials Flow (transparent to users)
- **Token Management:** Spotify access tokens managed server-side with automatic refresh

### Implementation Details

```typescript
// Server-side Spotify authentication
const getSpotifyToken = async (): Promise<string> => {
  const response = await fetch("https://accounts.spotify.com/api/token", {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: `Basic ${Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString("base64")}`,
    },
    body: "grant_type=client_credentials",
  });

  const { access_token } = await response.json();
  return access_token;
};

// Request validation middleware
const validateSpotifyRequest = async (req: Request) => {
  // 1. Validate Supabase JWT
  const user = await validateSupabaseAuth(req);

  // 2. Get fresh Spotify token (cached with TTL)
  const spotifyToken = await getSpotifyToken();

  req.user = user;
  req.spotifyToken = spotifyToken;
};
```

### Authorization Rules

- **User Isolation:** All API calls are scoped to authenticated user's data
- **Library Integration:** Recommendations automatically exclude user's library tracks and blocked tracks
- **Rate Limiting:** Per-user rate limits to prevent abuse

## 4. Validation and Business Logic

### Request Validation

#### Track Search

- `q`: Required, minimum 1 character, maximum 100 characters
- `limit`: Integer between 1 and 50
- `offset`: Non-negative integer
- **Genre filtering:** Implicit metal/rock genre preference in search algorithm

#### Track Details

- `spotify_track_id`: Required, exactly 22 characters, alphanumeric + underscore/hyphen
- **Market validation:** Must be valid ISO 3166-1 alpha-2 country code

#### AI Recommendations

- `base_track_id`: Must exist in user's library (validated against Supabase)
- `description`: Minimum 30 characters, maximum 500 characters
- `temperature`: Float between 0.0 and 1.0
- `count`: Integer between 1 and 10

### Business Logic Implementation

#### Recommendation Engine Integration

```typescript
const generateRecommendations = async (
  userId: string,
  baseTrackId: string,
  description: string,
  temperature: number
) => {
  // 1. Get user's exclusion lists
  const [libraryTracks, blockedTracks] = await Promise.all([
    getUserLibraryTrackIds(userId),
    getActiveBlockedTrackIds(userId),
  ]);

  const excludedTracks = [...libraryTracks, ...blockedTracks];

  // 2. Get base track details from Spotify
  const baseTrack = await getSpotifyTrackDetails(baseTrackId);

  // 3. Generate AI recommendations
  const aiPrompt = buildRecommendationPrompt(baseTrack, description, temperature);
  const aiResponse = await callOpenAIAPI(aiPrompt);

  // 4. Validate and enrich recommendations
  const recommendations = await Promise.all(
    aiResponse.trackIds
      .filter((id) => !excludedTracks.includes(id))
      .slice(0, 10)
      .map(async (trackId) => {
        const trackDetails = await getSpotifyTrackDetails(trackId);
        const artistBio = await generateArtistBio(trackDetails.artists[0]);
        return {
          ...trackDetails,
          ai_reasoning: aiResponse.reasoning[trackId],
          artist_bio: artistBio,
          recommendation_confidence: aiResponse.confidence[trackId],
        };
      })
  );

  return recommendations;
};
```

#### AI Prompt Engineering

```typescript
const buildRecommendationPrompt = (baseTrack: Track, description: string, temperature: number) => {
  const getPopularityInstruction = (temp: number): string => {
    if (temp <= 0.2) {
      return `Focus on VERY POPULAR and mainstream metal tracks that have broad appeal. 
      Prioritize tracks with high Spotify play counts (>10M streams). 
      Include well-known bands like Metallica, Iron Maiden, Black Sabbath level popularity.
      Avoid underground or obscure bands entirely.`;
    } else if (temp <= 0.4) {
      return `Focus on POPULAR metal tracks with some variety. 
      Include established bands with good recognition but not necessarily mainstream hits.
      Target tracks with moderate-to-high play counts (1M-10M streams).
      Mix of classic metal and newer popular releases.`;
    } else if (temp <= 0.6) {
      return `Provide a BALANCED MIX of popular and lesser-known metal tracks.
      Include both established bands and emerging artists.
      Mix tracks with varying play counts (100K-5M streams).
      Good blend of classic, modern, and underground influences.`;
    } else if (temp <= 0.8) {
      return `Lean towards UNDERGROUND and niche metal tracks.
      Prioritize lesser-known bands and hidden gems.
      Focus on tracks with lower play counts (10K-500K streams).
      Include bands from metal's deeper subgenres and regional scenes.`;
    } else {
      return `Focus on VERY UNDERGROUND and obscure metal tracks.
      Prioritize extremely niche bands and rare finds.
      Target tracks with very low play counts (<50K streams).
      Include experimental, avant-garde, and highly specialized subgenres.
      Embrace the most underground and cult metal acts.`;
    }
  };

  const getDiscoveryInstructions = (temp: number): string => {
    if (temp <= 0.3) {
      return "Prioritize safety and familiarity. Stick to widely recognized metal classics.";
    } else if (temp <= 0.5) {
      return "Balance familiarity with mild exploration. Include some deeper cuts from known artists.";
    } else if (temp <= 0.7) {
      return "Encourage musical exploration. Mix known artists with promising unknowns.";
    } else {
      return "Maximize discovery potential. Push boundaries and introduce truly unique finds.";
    }
  };

  const popularityInstruction = getPopularityInstruction(temperature);
  const discoveryInstruction = getDiscoveryInstructions(temperature);

  return `
    Base track: "${baseTrack.name}" by ${baseTrack.artists[0].name}
    User preference: "${description}"
    Temperature level: ${temperature} (0.0 = mainstream, 1.0 = underground)
    
    POPULARITY GUIDANCE:
    ${popularityInstruction}
    
    DISCOVERY APPROACH:
    ${discoveryInstruction}
    
    ADDITIONAL REQUIREMENTS:
    - Generate 10 metal track recommendations (Spotify track IDs) with reasoning
    - Ensure variety in release years (don't cluster in one decade)
    - Consider both vocal and instrumental similarities to base track
    - Weight recommendations based on the specific elements mentioned in user description
    
    Response format: JSON with trackIds, reasoning, and confidence scores.
    Each reasoning should explain both musical similarity and why it fits the popularity level requested.
  `;
};
```

#### Error Handling and Fallbacks

- **Spotify API Failures:** Graceful degradation with cached data where possible
- **OpenAI API Failures:** Fallback to basic recommendations based on track metadata
- **Rate Limiting:** Implement exponential backoff and request queuing

### Rate Limiting and Performance

- **Spotify Rate Limits:** 100 requests/second (managed at application level)
- **Caching Strategy:**
  - Track details: 24 hours TTL
  - Search results: 1 hour TTL (for identical queries)
  - Spotify access tokens: Based on token expiry

### Data Privacy and Security

- **No Spotify User Data:** Application never accesses private Spotify user information
- **Spotify Track IDs Only:** Store only public Spotify identifiers, no audio data
- **AI Processing:** User descriptions processed by OpenAI with data retention policies
- **Request Logging:** Log API usage for debugging while respecting user privacy
